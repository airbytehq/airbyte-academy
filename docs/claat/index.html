
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Build an AI Chatbot</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="12345"
                  id="airbyte-ai"
                  title="Build an AI Chatbot"
                  environment="web"
                  feedback-link="A link where users can go to provide feedback (e.g. the git repo)">
    
      <google-codelab-step label="Overview" duration="2">
        <p>In this tutorial, you will build an AI-powered chatbot to allow users to interact with e-commerce data. They will be able to ask natural language questions to uncover insights in the data.</p>
<p><a href="/3cTdWXCbT_atl5FCfsbQsA" target="_blank">todo: short video of completed app</a></p>
<p>[name=Justin Chao]</p>
<h2 is-upgraded>What You Will Learn</h2>
<p>In this tutorial, you will learn the following how to deploy, configure, and create an AI+data full stack application.</p>
<p class="image-container"><img alt="Intelligent Data Stack (5)" src="img/93eb59a4b8d738c9.png"></p>
<p>You will get hands on with:</p>
<ul>
<li>Airbyte Cloud to connect to Stripe test data</li>
<li>Use the Airbyte Postgres Destination connector to send Stripe data to Postgres, deployed on Supabase</li>
<li>Configure Supabase to use PGVector to support embeddings</li>
<li>Create a data pipeline in Airbyte to handle sync tasks and send data embeddings for AI use cases</li>
<li>Create SQL functions to work with openAI question embeddings</li>
<li>Write python-based chatbot uses OpenAI APIs to interact with your data and embeddings.</li>
<li>(bonus) Create a full-stack web application with a frontend in Next.js, to host your chatbot</li>
</ul>
<p>Whilst a basic understanding of coding in Next.js, Python, and SQL is helpful, if you are not comfortable with coding in these languages, don&#39;t worry! All of the code will be provided for you throughout.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Pre-requisites" duration="10">
        <p>To get started, you will need to set up the following accounts. Lucky for you - you can complete this entire course using free or trial versions. You will not require a credit card or paid account.</p>
<ol type="1">
<li>Stripe: Stripe is a very popular platform for processing online payments, with great developer APIs. You will need to <a href="https://dashboard.stripe.com/register" target="_blank">Sign up</a> for Stripe account. This will allow you to access test Stripe data for users, products, invoices, and purchases. You do not need to add any payments information. You can skip this during the setup.</li>
<li>Airbyte Cloud: Airbyte will be used as the data movement platform connecting Stripe with a modern database like Postgres to enable RAG applications. You will use a 14-day trial of Airbyte Cloud. You can <a href="https://cloud.airbyte.com/signup?utm_medium=lms&utm_source=course-ai" target="_blank">sign up here</a>. If you already have an Airbyte Cloud account, please feel free to use this.</li>
<li>Supabase: Supabase is a cloud-based backend-as-a service. At it&#39;s core, it is a managed PostgresSQL database. We will use this database, with the PGVector extension to build a RAG application. [Sign up here] (https://supabase.com/dashboard/sign-in) and create an empty project, giving it whatever name you like.</li>
<li>OpenAI: OpenAI, the makers of chatGPT provide an API platform for developers to build solutions with natural language processing and similarity search. <a href="https://auth.openai.com/authorize" target="_blank">Sign up for a free account.</a> You will use this for your chatbot to perform searches on your data.</li>
<li>Google Account: You will create the chatbot code in Python using a Google Collab notebook. In order to do so, you will need a <a href="https://accounts.google.com/lifecycle/steps/signup/name" target="_blank">free gmail account</a>. If you prefer to code locally, in your favorite IDE instead of a collab notebook, please do so, just keep in mind, this tutorial will not cover local Python environment configuration.</li>
</ol>
<p>Once you have created all of your accounts. Let&#39;s continue.</p>


      </google-codelab-step>
    
      <google-codelab-step label="A Quick AI Terminology Primer" duration="5">
        <p>There are a lot of new terms when working with AI. They can be overwhelming, but they don&#39;t have to be. Here is a quick primer on the most important things you need to understand. Throughout this tutorial, you will apply many of these techniques in your app.</p>
<ol type="1">
<li><strong>RAG</strong> (Retrieval-Augmented Generation) is an AI architecture which can produce accurate and relevant outputs. In this tutorial, RAG will be used to allow the end user to ask questions such as &#34;what are the most popular products sold?&#34;. RAG relies on three key technologies: the retrieval system (for this example, embeddings), model (for this example, openAI&#39;s LLM), and vector embeddings (for this example, via PGVector)</li>
<li><strong>LLM</strong>: An LLM (Large Language Model) is a type of artificial intelligence model designed to understand and generate human-like text. It is trained on massive datasets of text from diverse sources and uses advanced machine learning techniques to process and generate language. In this tutorial, we will use OpenAI&#39;s LLM.</li>
<li><strong>Embeddings</strong>: Embeddings are a type of representation that transforms data (such as text, images, or other inputs) into dense, low-dimensional vectors of numbers. This makes it easier to perform searches against the data, as it is comparing numbers.</li>
<li><strong>Similarity search</strong>: Similarity search is a technique used to find data items that are most similar to a given query item. It is widely applied in tasks where the goal is to retrieve or rank items based on their similarity in content, context, or structure. It is performed against embeddings.</li>
<li><strong>Hallucinations</strong>: A hallucination refers to a scenario where a generative model, such as a large language model (LLM) that looks correct but factually incorrect, logically flawed, or completely fabricated. The best way to avoid hallucinations is to provide LLMs with domain-specific data. In this case, the data we will provide the LLM will come from Stripe.</li>
</ol>
<p class="image-container"><img alt="ai-terminology" src="img/203c00a4ce8f7a97.png"></p>
<p>With a primer on key terminology out of the way, it is time to start building your app.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Configure Stripe" duration="5">
        <p>Log into the  Stripe account that you create earlier. make sure that you see the orange Test mode banner at the top. This means you are working with test data and no payment processing will occur. If you do not see this, please click the test mode toggle on the upper right.</p>
<p>Once you have your Stripe environment in Test mode, tap Developers in the lower left, then select API keys. Copy the Secret key. You will need this in the next step. <img alt="CleanShot 2025-01-14 at 10.06.45@2x" src="img/5001ea26cfbb08b2.png"></p>
<h2 is-upgraded>Load Test Data</h2>
<p>A chatbot is pretty boring without data. We will be retrieving data from Stripe for products, customers, and purchases. To save some time, we have created a  <a href="https://colab.research.google.com/drive/1hozY9eZ3g37NtBwBU1hDVujfJtfrpW-5?usp=sharing//" target="_blank">python script</a> to load test data. From within, the Colab notebook. You will see 3 steps in the collab notebook:</p>
<ul>
<li>Add a secret key (tap on the key icon on the left) STRIPE_TEST_KEY and use the value from the previous section.</li>
<li><ul>
<li>install the stripe library</li>
</ul>
</li>
<li>run the script to create and insert test data. <img alt="CleanShot 2025-01-14 at 10.08.32@2x" src="img/b191fdbc4ee9ab97.png"></li>
</ul>
<p>When you run the script, watch for the debug output. Ensure that you see a line which says <em>Sample data creation complete.</em></p>


      </google-codelab-step>
    
      <google-codelab-step label="Configure Supabase" duration="0">
        <p>We are going to use Supabase as the backend and database portion of the chatbot. You should have already completed the pre-requisites and have a Supabase account. If not, <a href="https://supabase.com/dashboard/sign-up" target="_blank">please create one now</a>.</p>
<p>Once logged in, if you haven&#39;t created a Project already, tap <em>New Project</em> and select the Organization which you created previously. Name the project, &#34;AirbyteAIBot&#34; and Tap &#34;Create new project&#34;.</p>
<p>:::info If you can not name your project upon initial set up, you can always do it later. Don&#39;t worry, the name is not important for any of the code we will write. :::</p>
<p>Once your project is created, there are a few important things to note, especially when creating Destination connectors from Airbyte, in particular, Project URL and API Key. You will need these shortly. You can always access these keys, via Settings &gt; API (under Configuration) if you need them.</p>
<p class="image-container"><img alt="CleanShot 2024-12-23 at 11.54.55" src="img/28700fd7d0bbf926.png"></p>
<p>Supabase automatically creates a database on your behalf. Tapping on the database icon on the left navigation, and ensuring you have the public schema selected, Supabase currently shows no tables have been created yet. Don&#39;t worry, these will be automatically created by Airbyte when you sync data for the first time. <img alt="CleanShot 2024-12-23 at 12.04.41" src="img/65d74bbbc64d984c.png"></p>
<h2 is-upgraded>Enable PGVector Extension</h2>
<p>One thing you do need to do is enable PGVector. PGVector is an extension to Postgres to allow it to create and store embeddings. Tap Extensions in the database submenu, and type &#34;PGVector&#34; into the search box, then enable the extension via the toggle.</p>
<p class="image-container"><img alt="CleanShot 2024-12-23 at 12.07.54" src="img/a94f8e9f90bd8dc.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Create Source Connector &amp; Streams" duration="10">
        <p>At this point, we have know the source of the data (stripe) and where we want to move the data, or destination (postgres on supabase). It is time to move the data. For this, we will use the Airbyte Cloud platform. To get started, you will need access to your <a href="https://cloud.airbyte.com/signup?utm_campaign=TDD_Search_Brand_USA&utm_source=adwords&utm_term=airbyte%20cloud&_gl=1*v7yfqs*_gcl_aw*R0NMLjE3MzQ5ODcwNDAuQ2owS0NRaUFzYVM3QmhEUEFSSXNBQVg1Y1NBOEFiMXd5RE45YzNOVFRRYU04ODNHdU5VRDBwV2RyUXlrYWp0OWI0WGJrMVNSQnRpUGpOa2FBakdrRUFMd193Y0I.*_gcl_au*OTc3Mjg2MDc0LjE3MzA4NDY2MjIuNDg2MzQ0NDM3LjE3MzIwNTI0ODAuMTczMjA1MjQ3OQ..//" target="_blank">Airbyte credentials</a>, and we will establish our connection first.</p>
<p>Within Airbyte, tap Builder in the left menu, then New custom Connection.</p>
<p class="image-container"><img alt="airbytecircles" src="img/f4f9dee35835f630.png"></p>
<p>You will be presented with options to create your connector. Select Start from Scratch.</p>
<p>We&#39;re starting from scratch to have complete control over our API configuration and to precisely define what Stripe data we want to include in our AI pipeline.</p>
<p class="image-container"><img alt="startfromscratch " src="img/a3b43164ba525060.png"></p>
<p>:::info Airbyte offers a pre-built Stripe connector. We could have used this in the tutorial, but wanted to get you hands-on with the connector builder, and it allows us more control over specific fields that we want to sync. :::</p>
<p>We&#39;ll use manual connector setup rather than the AI Assistant. This method works best when you need precise control over your API data collection.</p>
<p class="image-container"><img alt="manually" src="img/dc7115a1fdfa9d14.png"></p>
<p>For the base URL, you can use https://api.stripe.com, and Bearer token is used here for Auth: <img alt="stripeurl" src="img/435f0747ee1f8197.png"></p>
<p>If you click on the &#34;Testing Values&#34; button on the top right, you can see where to put your Stripe API key. Using the <a href="https://dashboard.stripe.com/test/apikeys" target="_blank">secret API key</a> in test mode will probably be the best way to do this.</p>
<p class="image-container"><img alt="stripeapikey" src="img/3d2a66fdff126593.png"></p>
<p>Now that we have the global configuration setup, let&#39;s tackle the actual data streams:</p>
<p>We have four streams in this tutorial that capture the most useful data:</p>
<ul>
<li>Customers</li>
<li>Search Customer</li>
<li>Invoices</li>
<li>Products</li>
</ul>
<h2 is-upgraded>Customers</h2>
<p>To set up the Customer Stream, see the <a href="https://docs.stripe.com/api/customers" target="_blank">customers endpoint</a> - /v1/customers. This is of course, our URL path! Click the plus button to get started:</p>
<p class="image-container"><img alt="customer-stream-setup" src="img/16b18b37a57df26c.png"></p>
<p>We are sending a GET request and getting JSON as the response. Record selector is selected here which is essential for filtering the records of data.</p>
<p class="image-container"><img alt="customerstream" src="img/797683a6fc16f684.png"></p>
<h2 is-upgraded>Search Customer</h2>
<p>For the search customer stream, you can use - <a href="https://docs.stripe.com/api/customers/search//" target="_blank">/v1/customers/search </a>as the endpoint. On the right, you can see the response if you filter query by specific email.</p>
<p class="image-container"><img alt="search-customer-stream" src="img/814e3dfab829b13b.png"></p>
<h2 is-upgraded>Invoices</h2>
<p>Use <a href="https://docs.stripe.com/api/invoices//" target="_blank">/v1/invoices</a> for the endpoint.</p>
<h2 is-upgraded>Products</h2>
<p>Use <a href="https://docs.stripe.com/api/products//" target="_blank">/v1/products</a> for the endpoint.</p>
<p>Note that invoices and products are set up the same way, but you can choose to add whatever field path is best and pagination if needed.</p>
<p>After building the streams, we can publish the custom connector. Now we just need to build the final connection! Click &#34;Publish&#34; on the top right corner.</p>
<p class="image-container"><img alt="connector-published" src="img/82bdddf10c486b8c.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Create Destination Connector" duration="0">
        <p>To build out the full connection, we set up <a href="https://supabase.com/docs/guides/database/extensions/pgvector//" target="_blank">PGVector</a> as our destination. This allows for vector similarity search,  which will be powerful as shown later.</p>
<p class="image-container"><img alt="ssq" src="img/e0a7212d33cb1e9.png"></p>
<p class="image-container"><img alt="seup-destination" src="img/1df0e8201a48ea1d.png"></p>
<p class="image-container"><img alt="ss2" src="img/16f3ee636b5e7cdc.png"></p>
<p class="image-container"><img alt="pgvector" src="img/c2b7b03030447604.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Sync Data" duration="3">
        <ul>
<li>choose stream</li>
<li>set up sync options. Overwrite, full sync etc.\</li>
<li>set embeddings.</li>
<li>indexing</li>
<li>run sync and show timeline and logs</li>
<li>log into superbase and look at customers, invoices, products. Notice the embeddings.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Recap: Data Movement Pipeline" duration="3">
        <p>Congratulations! You&#39;ve achieved a lot in a short amount of time. You&#39;ve created a fully functioning data movement pipeline. You&#39;ve taken data from source such as Stripe and moved it into an AI capable data storage product like Postgres and PGVector. By using Airbyte Cloud, you can quickly schedule when to move data, handle incremental changes in that data, and easily add new data sources ensuring that any AI app you build atop this data pipeline has the most up-to-date and relevant information. Remember, at the heart of AI is access to the right data.</p>
<p><a href="/AlvfEoJOTha-p_xb6wWTcw" target="_blank">todo: create version of the arch diagram that has a prominant data pipeline</a></p>
<p>Next, you will create the database functions as the sort of interface for your AI chatbot</p>


      </google-codelab-step>
    
      <google-codelab-step label="Create Database Functions" duration="10">
        <p class="image-container"><img alt="CleanShot 2024-12-23 at 12.26.28" src="img/69957df47dd41d8.png"></p>
<p>Before we do however, we need to create a few helper functions. These functions, one for each table, will pass in a question vector from openAI and compare this to the embedding of each record to find matches. Put simply, openAI takes a natural language question, converts it to a vector or numerical value, then we want to compare this to the numerical value of the embedding. The closer these two numbers are, the more relevant the results are.</p>
<p>Let&#39;s go ahead and create each function. From within Supabase, make sure you are in the database section, then tap Functions, Create new function. Repeat this process to create the following three functions. Each function takes a single argument, question_vector, of return type vector.</p>
<p>:::info</p>
<p>For this section, you will have to use PLpgSQL in the function definition, which is essentially just an extension on top of normal SQL. This may cause syntax errors so we reccomend using SQL editor to test in, as your playground!</p>
<p>:::</p>
<h2 is-upgraded>find_related_customer</h2>
<pre><code>SELECT *
    FROM customers     
    ORDER BY embedding &lt;=&gt; question_vector;
</code></pre>
<h2 is-upgraded>find_related_invoices</h2>
<pre><code>SELECT *
    FROM invoices     
    ORDER BY embedding &lt;=&gt; question_vector
</code></pre>
<h2 is-upgraded>find_related_products</h2>
<pre><code>    SELECT *
    FROM products     
    ORDER BY embedding &lt;=&gt; question_vector
</code></pre>
<p>That&#39;s it. Make sure all of your work is saved, and your Airbyte Sync is complete and populated data. Now it&#39;s time to create the chatbot.</p>
<p class="image-container"><img alt="Screenshot 2025-01-07 at 12.02.20\u202fPM" src="img/48b11dd1dacedf0f.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="The AI Chatbot" duration="20">
        <p>You will create the AI chatbot in Python. To make things simple, we will use a Google Collab notebook. You can think of this as an online IDE. Go ahead and navigate to <a href="https://colab.research.google.com/" target="_blank">Google Collab</a> and create a new notebook called airbyteai. If you would prefer to follow along, here is <a href="https://colab.research.google.com/drive/1B8QXrUGPi5JvjOwVREoGdAK72AJyU5fy#scrollTo=HVDlskc0S6ry" target="_blank">a completed notebook</a> for you.</p>
<p>:::info At the end of each step, don&#39;t forget to tap the Run button beside the code to have Collab execute it for you. :::</p>
<h2 is-upgraded>Add Required Libraries</h2>
<p>Install the required libraries.</p>
<pre><code>pip install supabase; openai

</code></pre>
<p>Then, import everything into your project space.</p>
<p>:::info You may notice that we didn&#39;t import os. This is automatically available in the collab notebook. :::</p>
<pre><code>import os
from supabase import create_client, Client
import openai
</code></pre>
<h2 is-upgraded>Configure Supabase Client</h2>
<p>We need to configure the supabase client using the URL and Client key that we previously used in the Airbyte Destination Configuration. To keep things secure, we want to use secrets. If you are not using a Collab notebook, I encourage you to use their environment variables or a .env file to avoid hardcoding sensitive information in your app.</p>
<p>Within Collab, tap the key icon on the left, and add two secrets. Both of these may be obtained within Supabase via Settings &gt; Configuration &gt; API python.</p>
<ul>
<li>SUPABASE_URL</li>
<li>SUPABASE_KEY</li>
</ul>
<p class="image-container"><img alt="CleanShot 2024-12-23 at 13.10.04" src="img/151cc3a60b004363.png"></p>
<p>Now, configure your client</p>
<pre><code>from google.colab import userdata

url = userdata.get(&#39;SUPABASE_URL&#39;)
key = userdata.get(&#39;SUPABASE_KEY&#39;)
supabase: Client = create_client(url, key)
</code></pre>
<p>::: info When you tap run, if this is your first time accessing the keys, you will be prompted to grant access to the secrets. This is ok. Accept and continue. :::</p>
<h2 is-upgraded>Configure OpenAI</h2>
<p>Just like we did with Supabase, we need to add the OpenAI API key. G, OPENAI_API_KEY, add it to your code. To obtain an OpenAI API key, log into your OpenAI account, tap the cog icon in the upper right, then API Keys from the left hand menu, and finally tap Create New Secret Key.</p>
<p class="image-container"><img alt="CleanShot 2024-12-23 at 16.55.35" src="img/248baa545e38e65a.png"></p>
<p>Copy the key and create another secret in your Collab notebook. Then, we can reference it in our code.</p>
<pre><code>openaikey = userdata.get(&#39;OPENAI_API_KEY&#39;)
</code></pre>
<h2 is-upgraded>Create Embeddings</h2>
<p>Next, we need to write a helper function to take the input question from the user and get openAI to convert it into an embedding. We are going to use the text-embedding-3-small model. You can experiment with others, but this works great for our requirement.</p>
<pre><code># Function to get embedding vector for a question using OpenAI
def get_question_embedding(question):
    response = openai.embeddings.create(input=question, model=&#34;text-embedding-3-small&#34;)
    return response.data[0].embedding
</code></pre>
<h2 is-upgraded>Pass the Question to the right context (table)</h2>
<p>Now that we have a question, we need to ask the question against the correct dataset. This way, we can compare the embedding of the question against the embeddings of each row. To do this, let&#39;s create a simple if, else statement looking for context in the question. Specifically, we will look for a keyword that matches one of the tables that are part of the Airbyte sync job: customer, product, or invoice.</p>
<p>You will see that our calls to Supabase are using the functions we created earlier, and take the question_vector as the input parameter.</p>
<pre><code>def get_context(question) -&gt; str:
    # Get embedding for the question
    question_embedding = get_question_embedding(question)
    results = []
# Determine which table to query based on keywords in the question
    if &#34;customer&#34; in question.lower():
        query = supabase.rpc(&#34;find_related_customer&#34;, {&#39;question_vector&#39;: question_embedding}).execute()
    elif &#34;product&#34; in question.lower():
        query = supabase.rpc(&#34;find_related_products&#34;, {&#39;question_vector&#39;: question_embedding}).execute()
    elif &#34;invoice&#34; in question.lower():
        query = supabase.rpc(&#34;find_related_invoices&#34;, {&#39;question_vector&#39;: question_embedding}).execute()
    else:
        return &#34;No relevant context found for the given question.&#34;

    # Process query results
    for item in query.data:
        results.append(item)

    return results
</code></pre>
<h2 is-upgraded>Handle Responses</h2>
<p>All that is left is to handle the response to a question. Thankfully, openAI does all the heavy lifting for it. We just need to set up the prompt, and tell openAI which model to use and how many tokens to apply against my account.</p>
<pre><code># Function to get AI response using OpenAI&#39;s chat completion
def get_response(question: str):
    openai.api_key = openaikey
    response = openai.chat.completions.create(
        model=&#34;gpt-4o-mini&#34;,
        messages=[
            {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;You are a helpful assistant that answers questions about the customers, products, and invoices provided to you in the context. Use only the provided context to answer questions. If the information isn&#39;t in the context, say so.&#34;},
            {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: f&#34;Question: {question}\n\nContext:\n{get_context(question)}&#34;}
        ],
        max_tokens=150,
        temperature=0.7
    )
    return response.choices[0].message.content.strip()
</code></pre>
<h2 is-upgraded>Test it</h2>
<p>All that is left to do is write a quick test, run it and see our hard work pay off!</p>
<p>TODO: CONFIRM YOU CAN DO THIS ON A FREE PLAN. SHOULD AS LONG AS YOU HAVE TRIAL CREDITS</p>
<p>TODO: make more test. things like:</p>
<ul>
<li>what is the most common product sold?</li>
<li>when someone buys more than one product, what is the most common second product sold?</li>
<li>who made the cheapest purchase? How much did they pay, and what did they buy?</li>
<li>what is the most common purchase that women make?</li>
</ul>
<pre><code># Example usage
question = &#34;Is there a customer named Justin? If so, show me his information&#34;
answer = get_response(question)
print(&#34;Answer:&#34;, answer)
</code></pre>
<p class="image-container"><img alt="CleanShot 2024-12-23 at 17.14.56" src="img/37953a4a3ad73e05.png"></p>
<p>Congratulations! You have successfully built your AI chatbot powered by Airbyte.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Bonus: Create a Front End, Next.js" duration="15">
        <p>Now that we have our chatbot working in Python, let&#39;s create a web interface using Next.js. This will give users an intuitive way to interact with our AI-powered data analysis.</p>
<p>The app when finished, should look something like <a href="https://youtu.be/irh42TDNTFQ//" target="_blank">this</a>!</p>
<p>Follow along with the <a href="https://github.com/AkritiKeswani/ecommerce-chatbot//" target="_blank">GitHub repo</a> for reference! If you want a better idea of where to place files generally, see the directory structure below</p>
<pre><code>ecommerce-chatbot/
├── src/
│   ├── app/
│   │   ├── api/
│   │   │   └── chat/
│   │   │       └── route.ts         # API endpoint for chat
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   └── page.tsx                 # Main chat interface
│   ├── components/
│   │   └── ui/
│   │       ├── ChatInput.tsx        # Input component
│   │       ├── ChatMessage.tsx      # Message display component
│   │       └── theme-provider.tsx   # Theme configuration
│   ├── lib/
│   │   ├── openai.ts               # OpenAI client setup
│   │   └── supabase.ts             # Supabase client setup
│   └── types/
│       └── chat.ts                 # TypeScript interfaces
├── public/
│   └── favicon.ico
├── .env.local                      # Environment variables
├── .gitignore
├── eslint.config.mjs               # ESLint configuration
├── next.config.ts                  # Next.js configuration
├── next-env.d.ts                   # Next.js TypeScript declarations
├── package.json
├── package-lock.json
├── postcss.config.mjs              # PostCSS configuration
└── tsconfig.json                   # TypeScript configuration
</code></pre>
<h2 is-upgraded>Step 1: Setup Next.js Project</h2>
<pre><code>npx create-next-app@latest ecommerce-chatbot --typescript --tailwind --eslint
cd  ecommerece-chatbot
</code></pre>
<p><strong>Install Dependencies</strong></p>
<p><code>npm install @supabase/supabase-js openai</code></p>
<p><strong>Environment Variables</strong></p>
<p>Create <code>.env.local</code> in the root directory.</p>
<pre><code>NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
OPENAI_API_KEY=your_openai_key
</code></pre>
<h2 is-upgraded>Step 2: Create API Route</h2>
<p><code>(/api/chat/route.ts)</code></p>
<p>This is the most critical part of the app, where the user&#39;s query is:</p>
<ul>
<li>Categorized using GPT.</li>
<li>Processed to find relevant data using Supabase vector search.</li>
<li>Answered intelligently by GPT based on retrieved data. = Navigate to <code>app/api/chat/</code> and create a file named route.ts.</li>
</ul>
<p>This is where you set up connections to Supabase and OpenAI.</p>
<pre><code>import { NextResponse } from &#39;next/server&#39;;
import OpenAI from &#39;openai&#39;;
import { createClient } from &#39;@supabase/supabase-js&#39;;

// Initialize Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});
</code></pre>
<p>This generates the embedding for the user query.</p>
<pre><code>// Generate embedding for the user&#39;s query
async function getQueryEmbedding(message: string) {
  const response = await openai.embeddings.create({
    model: &#39;text-embedding-ada-002&#39;,
    input: message,
  });
  return response.data[0].embedding;
}
</code></pre>
<p>Now, we use GPT to determine whether the query is related to customers, products, or invoices.</p>
<pre><code>// Categorize the user&#39;s query
async function categorizeQuery(message: string) {
  const response = await openai.chat.completions.create({
    model: &#39;gpt-4&#39;,
    messages: [
      {
        role: &#39;system&#39;,
        content: `You are an e-commerce assistant. Categorize the query into one of these categories:
        - CUSTOMER: For accounts, profiles, personal details, users
        - PRODUCT: For items, inventory, specifications, pricing
        - ORDER: For payments, invoices, orders, shipping
        Respond with just the category name.`,
      },
      { role: &#39;user&#39;, content: message },
    ],
    temperature: 0.3,
    max_tokens: 10,
  });
  return response.choices[0].message.content?.trim().toUpperCase();
}
</code></pre>
<p>Now, we map the category to the right Supabase function:</p>
<pre><code>// Match query category to Supabase function
function getSupabaseFunction(category: string) {
  const functionMap = {
    CUSTOMER: &#39;find_related_customer&#39;,
    PRODUCT: &#39;find_related_products&#39;,
    ORDER: &#39;find_related_invoices&#39;,
  };
  return functionMap[category];
}
</code></pre>
<p>The function from Supabase is called and retrives the relevant data.</p>
<pre><code>// Query Supabase for related data
async function querySupabase(functionName: string, queryEmbedding: number[]) {
  const { data, error } = await supabase.rpc(functionName, {
    question_vector: queryEmbedding,
  });
  if (error) throw new Error(`Supabase error: ${error.message}`);
  return data;
}
</code></pre>
<p>GPT generates a final response.</p>
<pre><code>// Generate a meaningful response using GPT
async function generateGPTResponse(message: string, context: string) {
  const response = await openai.chat.completions.create({
    model: &#39;gpt-4&#39;,
    messages: [
      {
        role: &#39;system&#39;,
        content: &#39;You are an intelligent assistant. Use the provided context to answer the query clearly and concisely.&#39;,
      },
      {
        role: &#39;user&#39;,
        content: `Question: ${message}\n\nContext:\n${context}`,
      },
    ],
    temperature: 0.3,
    max_tokens: 300,
  });
  return response.choices[0].message.content;
}
</code></pre>
<p>Lastly, we can consolidate all of this into a POST function that is the final request:</p>
<pre><code>export async function POST(request: Request) {
  try {
    const { message } = await request.json();
    console.log(&#39;Incoming message:&#39;, message);

    // Step 1: Get embedding for the query
    const queryEmbedding = await getQueryEmbedding(message);

    // Step 2: Categorize the query
    const category = await categorizeQuery(message);
    console.log(&#39;Detected category:&#39;, category);

    if (![&#39;CUSTOMER&#39;, &#39;PRODUCT&#39;, &#39;ORDER&#39;].includes(category)) {
      return NextResponse.json({
        content: &#39;Please ask about customers, products, or orders.&#39;,
      });
    }

    // Step 3: Match category to Supabase function
    const functionName = getSupabaseFunction(category);
    console.log(&#39;Matched function:&#39;, functionName);

    // Step 4: Query Supabase
    const documents = await querySupabase(functionName, queryEmbedding);
    const context = documents?.map((doc: any) =&gt; doc.document_content).join(&#39;\n&#39;) || &#39;No relevant data found.&#39;;

    // Step 5: Generate GPT response
    const response = await generateGPTResponse(message, context);

    return NextResponse.json({ content: response });
  } catch (error: any) {
    console.error(&#39;Error:&#39;, error.message);
    return NextResponse.json({ error: &#39;Something went wrong.&#39; }, { status: 500 });
  }
}
</code></pre>
<h2 is-upgraded>Step 3: Entry Point for App</h2>
<p>Once you complete the route, you will have to add to <code>page.tsx</code> as that is your main entry point:</p>
<pre><code>&#39;use client&#39;;

import { useState } from &#39;react&#39;;
import ChatInput from &#39;./components/ChatInput&#39;;
import ChatMessage from &#39;./components/ChatMessage&#39;;

interface Message {
  role: &#39;user&#39; | &#39;assistant&#39;;
  content: string;
}

export default function Chat() {
  const [messages, setMessages] = useState&lt;Message[]&gt;([]);
  const [input, setInput] = useState(&#39;&#39;);
  const [isLoading, setIsLoading] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!input.trim()) return;

    const userMessage = { role: &#39;user&#39;, content: input };
    setMessages((prev) =&gt; [...prev, userMessage]);
    setInput(&#39;&#39;);
    setIsLoading(true);

    try {
      const response = await fetch(&#39;/api/chat&#39;, {
        method: &#39;POST&#39;,
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
        body: JSON.stringify({ message: input }),
      });

      const data = await response.json();
      const assistantMessage = { role: &#39;assistant&#39;, content: data.content };

      setMessages((prev) =&gt; [...prev, assistantMessage]);
    } catch (error) {
      setMessages((prev) =&gt; [
        ...prev,
        { role: &#39;assistant&#39;, content: &#39;Something went wrong. Please try again.&#39; },
      ]);
    } finally {
      setIsLoading(false);
    }
  }

  return (
    &lt;main className=&#34;max-w-3xl mx-auto p-4&#34;&gt;
      &lt;div className=&#34;bg-gray-100 rounded p-4 h-[500px] overflow-y-auto mb-4&#34;&gt;
        {messages.map((msg, i) =&gt; (
          &lt;ChatMessage key={i} message={msg} /&gt;
        ))}
      &lt;/div&gt;
      &lt;ChatInput
        input={input}
        setInput={setInput}
        handleSubmit={handleSubmit}
        isLoading={isLoading}
      /&gt;
    &lt;/main&gt;
  );
}
</code></pre>
<h2 is-upgraded>Step 4: Simple Chat UI</h2>
<p>In order to structure how the chatbot itself looks, we would need ChatInput.tsx and ChatMessage.tsx as components that help manage how the input looks to users when they type questions + display user queries in the chat-like format.</p>
<p>components/ui/ChatInput.tsx:</p>
<pre><code>import React from &#39;react&#39;;

interface ChatInputProps {
  input: string;
  setInput: (input: string) =&gt; void;
  handleSubmit: (e: React.FormEvent) =&gt; Promise&lt;void&gt;;
  isLoading: boolean;
}

export default function ChatInput({ input, setInput, handleSubmit, isLoading }: ChatInputProps) {
  return (
    &lt;form onSubmit={handleSubmit} className=&#34;relative flex w-full&#34;&gt;
      &lt;input
        type=&#34;text&#34;
        value={input}
        onChange={(e) =&gt; setInput(e.target.value)}
        placeholder=&#34;Ask me about customers, products, or orders...&#34;
        className=&#34;w-full px-4 py-3 pr-16 rounded-xl border border-gray-200 focus:border-gray-500 focus:ring-2 focus:ring-gray-100 outline-none transition-all&#34;
        disabled={isLoading}
      /&gt;
      &lt;button
        type=&#34;submit&#34;
        disabled={isLoading}
        className=&#34;absolute right-3 top-1/2 -translate-y-1/2 p-2 rounded-lg bg-gray-800 hover:bg-gray-900 text-white transition-colors disabled:opacity-50 disabled:cursor-not-allowed&#34;
      &gt;
        {isLoading ? &#39;...&#39; : &#39;Send&#39;}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>components/ui/ChatMessage.tsx:</p>
<pre><code>import React from &#39;react&#39;;
import { Message } from &#39;@/app/types/chat&#39;;

interface ChatMessageProps {
  message: Message;
}

export default function ChatMessage({ message }: ChatMessageProps) {
  return (
    &lt;div
      className={`flex ${
        message.role === &#39;user&#39; ? &#39;justify-end&#39; : &#39;justify-start&#39;
      }`}
    &gt;
      &lt;div
        className={`max-w-[80%] rounded-sm px-4 py-3 font-light ${
          message.role === &#39;user&#39;
            ? &#39;bg-black text-white&#39;
            : &#39;bg-gray-50 border border-gray-200&#39;
        }`}
      &gt;
        &lt;pre className=&#34;whitespace-pre-wrap font-mono text-sm&#34;&gt;
          {message.content}
        &lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 is-upgraded>Security Note</h2>
<p>For production:</p>
<ul>
<li>Move OpenAI Calls to API Routes:</li>
<li>Protect API keys by handling all OpenAI calls server-side in /api/chat.</li>
<li>Add Authentication:</li>
<li>Use tools like NextAuth.js to restrict access, ensuring only authorized users can query the app.</li>
<li>Set Up CORS: Allow requests only from trusted domains to secure your backend.</li>
<li>Secure environment vairables.</li>
</ul>
<h2 is-upgraded>Recap &amp; Overview</h2>
<p>As you can see below, our app flow is as follows:</p>
<p class="image-container"><img alt="ecommerce-assistant-chatbot" src="img/4c0429c641e43280.png"></p>
<h2 is-upgraded>Data Pipeline:</h2>
<ul>
<li>Stripe API provides structured data (customers, products, invoices).</li>
<li>Airbyte syncs this data into Supabase with PGVector enabled, allowing semantic search.</li>
</ul>
<h2 is-upgraded>Query Flow:</h2>
<ul>
<li>User questions are sent from the frontend to a backend API.</li>
<li>OpenAI converts the query into embeddings, and GPT categorizes it (e.g., customer, product, or order).</li>
<li>Supabase retrieves relevant data using vector similarity, which GPT transforms into a meaningful response.</li>
</ul>
<h2 is-upgraded>Key Features:</h2>
<ul>
<li>PGVector: Performs vector similarity searches on e-commerce data.</li>
<li>Supabase SQL Functions: Route queries to the correct tables.</li>
<li>OpenAI GPT: Enhances the experience with human-like responses.</li>
<li>Next.js Frontend: Provides a user-friendly, real-time chat interface.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Next Steps" duration="2">
        

      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
